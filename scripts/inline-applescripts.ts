#!/usr/bin/env -S deno run --allow-read --allow-write
/**
 * Build script to inline AppleScript files for JSR compatibility
 *
 * Walks through plugin directories and generates index.ts files in each scripts/
 * directory that contain inlined versions of all .applescript and .scpt files.
 *
 * - .applescript files: Inlined as plain text strings
 * - .scpt files: Inlined as base64-encoded binary data
 *
 * Usage:
 *   deno run --allow-read --allow-write scripts/inline-applescripts.ts
 */

import { walk } from '@std/fs/walk';
import { dirname, join, relative } from '@std/path';
import { encodeBase64 } from '@std/encoding/base64';

const SERVER_ROOT = './server/src/plugins';
const SCRIPTS_DIR_NAME = 'scripts';

interface InlinedScript {
  type: 'text' | 'binary';
  content: string;
}

type ScriptsMap = Record<string, InlinedScript>;

async function findScriptDirectories(): Promise<string[]> {
  const scriptDirs: string[] = [];

  for await (const entry of walk(SERVER_ROOT, { includeDirs: true, includeFiles: false })) {
    if (entry.name === SCRIPTS_DIR_NAME) {
      scriptDirs.push(entry.path);
    }
  }

  return scriptDirs;
}

async function collectScripts(scriptsDir: string): Promise<ScriptsMap> {
  const scripts: ScriptsMap = {};

  for await (const entry of walk(scriptsDir, { includeFiles: true, includeDirs: false })) {
    const filename = relative(scriptsDir, entry.path);

    // Process .applescript files as text
    if (filename.endsWith('.applescript')) {
      const content = await Deno.readTextFile(entry.path);
      scripts[filename] = {
        type: 'text',
        content,
      };
    } // Process .scpt files as base64 binary
    else if (filename.endsWith('.scpt')) {
      const binaryContent = await Deno.readFile(entry.path);
      const base64Content = encodeBase64(binaryContent);
      scripts[filename] = {
        type: 'binary',
        content: base64Content,
      };
    }
  }

  return scripts;
}

function generateIndexTs(scripts: ScriptsMap): string {
  const entries = Object.entries(scripts);

  if (entries.length === 0) {
    return `/**\n * Inlined AppleScript files for JSR compatibility\n * Generated by scripts/inline-applescripts.ts\n */\n\nexport const INLINED_SCRIPTS = {};\n`;
  }

  let code =
    `/**\n * Inlined AppleScript files for JSR compatibility\n * Generated by scripts/inline-applescripts.ts\n * DO NOT EDIT - This file is auto-generated\n */\n\n`;
  code += `export interface InlinedScript {\n`;
  code += `  type: 'text' | 'binary';\n`;
  code += `  content: string;\n`;
  code += `}\n\n`;
  code += `export const INLINED_SCRIPTS: Record<string, InlinedScript> = {\n`;

  for (const [filename, script] of entries) {
    // Escape content for TypeScript template literal
    // Only escape text content - base64 doesn't contain special characters
    const escapedContent = script.type === 'text'
      ? script.content
        .replace(/\\/g, '\\\\')
        .replace(/`/g, '\\`')
        .replace(/\$/g, '\\$')
      : script.content; // base64 needs no escaping

    code += `  '${filename}': {\n`;
    code += `    type: '${script.type}',\n`;
    code += `    content: \`${escapedContent}\`,\n`;
    code += `  },\n`;
  }

  code += `};\n`;
  return code;
}

async function processScriptsDirectory(scriptsDir: string): Promise<void> {
  console.log(`Processing: ${scriptsDir}`);

  const scripts = await collectScripts(scriptsDir);
  const scriptCount = Object.keys(scripts).length;

  if (scriptCount === 0) {
    console.log(`  No scripts found, skipping`);
    return;
  }

  const indexPath = join(scriptsDir, 'index.ts');
  const indexContent = generateIndexTs(scripts);

  await Deno.writeTextFile(indexPath, indexContent);

  console.log(`  âœ“ Generated index.ts with ${scriptCount} script(s)`);
}

async function main() {
  console.log('\nðŸ”¨ Inlining AppleScript files for JSR compatibility...\n');

  const scriptDirs = await findScriptDirectories();

  if (scriptDirs.length === 0) {
    console.log('No scripts directories found');
    return;
  }

  for (const dir of scriptDirs) {
    await processScriptsDirectory(dir);
  }

  console.log('\nâœ… Done! Generated index.ts files are ready for JSR publishing.\n');
}

if (import.meta.main) {
  main();
}
